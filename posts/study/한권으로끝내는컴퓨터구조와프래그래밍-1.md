---
title: 한 권으로 끝내는 컴퓨터 구조와 프로그래밍 공부 1
date: 2025-04-26 16:42:12
category: study
tags: ["스터디", "CS"]
isPrivate: true
---

# 서론

CS 지식 부족을 느끼고 책을 읽기 시작했다. 우선 너무 오래 잡고 있기는 뭐하고 하루에 40분에서 한시간 정도 읽는 것으로 했는데 이 책을 다 읽고 나서 변화된 모습을 기대하며 기록해보겠습니다.
총 2일의 걸쳐 공부한 내용을 정리합니다.

집중력을 위해서도 있고 나중에 정리가 수월하게 하기 위해 필기를 하면서 읽었다.

우선, 들어가기 전에 저자가 한 말이 있는데 꽤나 인상 깊어서 간략히 필기해뒀다.

저자가 한 말 중에 인상 깊었던 것들은 다음인데,

- 여러 지식 인사이트 늘리기
- 프로그래밍의 역사에 대한 중요함

프로그래머는 사실 많은 지식을 알고 있는게 좋다는게 저자의 요지같았다. 동작 원리를 모르면 기능을 구현하지 못하니까... 사실 무슨 프로젝트를 들어가도 도메인은 중요한 것 같다. 내 상황을 예로 들어보자면 나는 "탄소관리 서비스" 에 대한 프로젝트에 중간에 투입이 되었는데 아무것도 모를 때보다 후에 간략하게 플로우나 서비스의 흐름 등을 알았을 때 일이 수월하게 돌아갔었다.

단순 개발 공부만이 아니라 여러 인사이트를 늘리려고 노력해야겠다.
사실 요즘 수학 공부도 관심 있고 기초 과학에도 관심이 생긴다.

두번째로 프로그래밍의 역사에 대한 중요성은 많은 프로그래머가 방대한 양이기 때문에 프로그래밍의 역사를 등한시 하는데 이걸 알아야 과거와 같은 실수를 하지 않는다는 것이 요지였다.

생각해보면 한국사 공부하는 이유와 같은 듯 하다.

이제 정말 공부한 내용으로 들어갑니다.

# 컴퓨터 내부와 언어 체계

- 컴퓨터는 bit 로 이루어져있음
- bit 는 binary 와 digit의 합성어
- 2진법을 사용하는데 적은 비용으로 편리하게 기호를 담을 수 있기 때문
- 논리 연산 : 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작
- 불리언 대수 :
  - 비트에 대해 사용할 수 있는 연산 규칙의 집합
    -> 결합 법칙, 교환 법칙, 분배 규칙 적용 가능 (NOT, OR, XOR)
  - NOT : 논리적 반대
  - AND 둘 이상의 비트에 적용. 2비트 연산의 경우 (예 : 첫번째 비트가 참이고 두번째 비트가 참이면 참)
  - OR : 둘 이상 비트에 적용 둘 중 하나가 참이면 참
  - XOR : 둘 이상 비트에 적용. 첫번째 비트와 두번째 비트가 다른 값인 경우 참

**진리표**
| A | B | A AND B | A OR B | A XOR B | NOT A |
|:-:|:-:|:-------:|:------:|:-------:|:-----:|
| 0 | 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 |

- 드모르간의 법칙
  - a AND b = NOT(NOT a OR NOT b) 자연어의 이중부정과 같음

## 정수를 비트로 표현하는 방법

- 사람은 지수를 적용할 밑을 10으로 사용하기 때문에 밑이 10(base-10)
- 2진수로 5,028은 13비트의 수
- LSB / MSB (각각 비트의 맨 오른쪽, 맨 왼쪽)
- 컴퓨터는 미리 정해진 수의 비트를 한 덩어리로 사용하도록 설계되었기 때문에 항상 일정한 비트를 사용해 값을 표현하는 경우가 종종 있음 (예 : 5,028 은 총 13 비트가 필요하지만 16비트로 나타냄)

### 2진수의 덧셈

- 결과가 1보다 크면 다음자리로 올림
- 논리 연산 이용해 2진 덧셈 수행
  - 더한 결과 = XOR
  - 올림 = AND
- 오버플로 : MSB에서 올림 발생
- 조건코드 레지스터 : 오버플로 비트가 있는데 MSB의 올림값이 들어감
  - 이 비트를 보면 오버플로 발생 여부 알 수 있음
  - 언더플로 : 오버플로와 반대. 이에 해당하는 조건 코드도 컴퓨터에 저장됨

### 음수 표현

- 부호와 크기 표현법 +, - 를 비트 중 한자리에 둠 (맨 왼쪽)
  - 문제점
    - 0을 표기하는 방법이 2개라 비용 낭비
    - XOR, AND를 통한 덧셈 불가능
- 1의 보수
  - 양수의 모든 비트 뒤집기
  - 1의 보수라는 문맥에서는 NOT 연산을 통해 보수를 얻음
  - 여전히 2가지 문제 존재
    - 1의 보수 덧셈 쉽게 할 수 없음
    - MSB 쪽에서 올림 발생 시 LSB로 올림 전달 : 순환 올림
- 2의 보수
  - 하드웨어 추가하지 않음. XOR, AND 연산만 이용 가능
    - +1에 더햇을 때 0이 나오는 비트 패턴을 찾고 이 패턴을 -1이라고 함
    - 4비트의 경우 +1은 0001, 1111 을 0001에 더하면 0000 => 1111 -1을 표현하는 비트 패턴
    - 가장 널리 쓰이는 방법
    - MSB에서 올림 발생하면 버림
    - 비트의 개수가 커지면 값의 범위가 지수적으로 증가

## 실수를 표현하는 방법

2진 소수점을 표현할 방법 필요

### 고정소수점 표현법

- 소수점의 위치를 임의로 정하기
  - (예 : 4비트 중 2 비트는 2진 소수점의 오른쪽에 있는 분수를 표현하는데 사용)
- 잘 작동하긴 하지만 쓸모 있는 범위의 실수값 표현하기 위해 필요한 비트의 개수가 너무 많음
- 디지털 신호처리 장치 등 특별한 목적에 쓰이는 일부 컴퓨터는 여전히 사용하기도 함 (범용 컴퓨터는 대부분 사용하지 않음)

> 범용 컴퓨터?
> : 일반적인 문제를 해결하기 위한 컴퓨터.
>
> 즉, 넓은 범위의 수 다룰 수 있어야 함.

### 부동 소수점 표현법

- 과학적 표기법을 2진수에 적용
  - 수를 해석하는 새로운 방법을 도입해서 큰 범위의 수를 표현
  - 10진 소수점 왼쪽이 한자리 뿐인 소수에 10을 몇번 거듭제곱 한 값을 곱하는 방식으로 소수 표현.
  - 예 : 0.0012 = 1.2x10^-3 = 1.2 X 0.001 = 0.0012
  - 가수 부분은 (소수점 왼쪽이 한자리 뿐인) 2진 소수. 지수 부분은 2의 거듭제곱 횟수를 표현

> **잠시 설명하고 지나갑니다..🚗**
>
> 예를 들면 1.101 => 1 (소수점 왼쪽), 101 소수점 오른쪽 <br />
> 지수 부분 : 2를 몇 번 곱하거나 나누는지 나타내는 숫자<br />
> 숫자가 너무 크면 2의 몇제곱을 곱해서<br />
> 숫자가 너무 작으면 2의 몇제곱을 나눠서<br />
> 예시 : 10진수 6.25 는 110.01 -> 소수점 왼쪽 2자리 한자리만 남게 조정 1.1101 X 2^2

- 부동 소수점의 비효율성
  - 비트 조합 중 낭비 많음
  - 비트 패턴이 가능한 모든 수를 표현하지는 못함
    - 지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커짐.<br />
      이로 인해 0.5와 0.5를 더하면 1.0을 얻을 수 있지만 0.5를 표현하는 비트표현이 없어서 0.5와 6.0 더할 수 없음.

# 다음에 이어서 할 것

IEEE 부동소수점 수 표준
